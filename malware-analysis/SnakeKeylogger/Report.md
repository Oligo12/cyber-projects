# SnakeKeylogger Malware Analysis Report
**Author:** Nikola Marković  
**Date:** 2025-12-26                                                                                        
**Version:** v1.1

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)  
2. [Scope & Methodology](#2-scope--methodology)  
3. [Analysis Environment](#3-analysis-environment)  
4. [Static Analysis](#4-static-analysis)
    - [Sample Metadata (Summary)](#41-sample-metadata-summary)
    - [Stage 1 PowerShell Loader](#42-stage-1-powershell-loader)
    - [Stage 1 Obfuscation & Decryption Logic](#43-stage-1-obfuscation--decryption-logic)
    - [Stage 2 PowerShell In-Memory Loader](#44-stage-2-powershell-in-memory-loader)
    - [.NET Loader (MAFIA) and Process Hollowing](#45-net-loader-mafia-and-process-hollowing)
    - [Final Payload Capabilities (SnakeKeylogger)](#46-final-payload-capabilities-snakekeylogger)
    - [Configuration & Exfiltration Channels](#47-configuration--exfiltration-channels)
    - [Static Indicators of Interest](#48-static-indicators-of-interest)
5. [Dynamic Analysis](#5-dynamic-analysis)
   - [High-Level Execution Chain (Observed)](#51-high-level-execution-chain-observed)
   - [Process Execution & Runtime Behavior](#52-process-execution--runtime-behavior)
   - [Privilege Context](#53-privilege-context)
   - [Network Activity](#54-network-activity)
   - [Keylogging Activity](#55-keylogging-activity)
   - [Summary](#56-summary)
6. [Persistence Mechanisms](#6-persistence-mechanisms)
7. [Memory / Forensic Artifacts](#7-memory--forensic-artifacts)
   - [Injected Payload Recovery](#71-injected-payload-recovery) 
8. [Indicators of Compromise (IOCs)](#8-indicators-of-compromise-iocs)  
   - [File Hashes](#81-file-hashes)
   - [Processes](#82-processes)
   - [Registry](#83-registry)
   - [Network Indicators](#84-network-indicators)
   - [Behavioral Indicators](#85-behavioral-indicators)
   - [Notable Strings](#86-notable-strings)
9. [Detections (Summary)](#9-detections-summary)  
10. [MITRE ATT&CK Mapping](#10-mitre-attck-mapping)
11. [Conclusion](#11-conclusion)
12. [Limitations & Future Work](#12-limitations--future-work)
13. [Appendices](#13-appendices)
    - [Appendix A - Execution Timeline](#appendix-a---execution-timeline) 

---

## 1. Executive Summary

This report documents the analysis of a Keylogger sample delivered via a multi-stage, PowerShell-based loader. The initial script employed Base64 encoding and RC4 encryption to conceal an embedded second-stage payload, which was decrypted at runtime and executed in memory via `Invoke-Expression`. The decrypted script subsequently loaded an intermediate .NET assembly in memory, which spawned and hollowed the legitimate Windows binary `aspnet_compiler.exe`, using it as a disposable host process for the final payload.

Static analysis confirmed functionality consistent with the Keylogger malware family, including credential harvesting and support for multiple data exfiltration mechanisms such as SMTP, HTTP, FTP, and Telegram. In the analyzed variant, only the SMTP module contained valid configuration data and embedded credentials; the remaining exfiltration methods were present in code but unconfigured.

Dynamic analysis using Process Monitor and Wireshark was performed primarily to validate the execution chain identified during static analysis. Runtime behavior confirmed the PowerShell staging logic, in-memory loading of the .NET loader, and abuse of `aspnet_compiler.exe` as a living-off-the-land host process. No active exfiltration traffic was observed during the detonation window, despite the presence of exfiltration logic in the payload.

Several outbound HTTP and HTTPS connections were observed from the hollowed `aspnet_compiler.exe` process. These resolved to common cloud and CDN infrastructure and are assessed as environmental noise associated with execution within a legitimate .NET host process, rather than attacker-controlled command-and-control activity.

Overall, the sample represents a commodity infostealer employing minimal obfuscation, with execution driven by in-memory PowerShell and .NET loaders and living-off-the-land binaries used primarily for payload hosting, lifecycle management, and defense evasion. Dynamic analysis corroborated static findings and did not reveal additional malicious capabilities beyond those identified through code analysis.

---

## 2. Scope & Methodology

### Scope

- Document the execution flow of a SnakeKeylogger sample staged via PowerShell.
- Identify the obfuscation layers used to conceal embedded payloads and recover plaintext code.
- Analyze decrypted payload logic to identify data collection functionality and supported exfiltration channels (and which are configured in this variant).
- Validate key behaviors with ProcMon/Wireshark and map techniques to MITRE ATT&CK.
- **Out of scope:** attribution, kernel/driver analysis, malware repacking.

### Methodology

- Revert to a clean snapshot between runs.
- Execute in an isolated Windows lab with controlled network access.
- Workflow:
  - Inspect PowerShell loader and extract/decrypt embedded payloads (Base64 -> RC4 -> UTF-8).
  - Review decrypted scripts/.NET components in dnSpy to identify functionality and configuration.
  - Confirm execution chain and observe runtime/network behavior using ProcMon, TCPView, and Wireshark.
- Collect logs/artifacts after each run for correlation.

### Tools Used

- **Static:** dnSpy, Detect It Easy (DIE), PowerShell ISE, CyberChef
- **Dynamic:** ProcMon, Wireshark, TCPView
- **Scripting:** Python (decryption), PowerShell (execution-flow modification and plaintext extraction)

---

## 3. Analysis Environment

**Lab Setup**

- **Microsoft Windows 10 Enterprise Evaluation (Version 22H2, OS Build 19045, FlareVM)** - malware detonation VM, patched, Windows Defender Antivirus and Windows Firewall disabled.
- **pfSense Firewall VM** - mediates all outbound traffic, configurable rules (DNS/HTTP/S only, ICMP, LAN-to-LAN, or full block). WAN interface connected through NAT.
- **REMnux VM** - positioned as a transparent bridge (Layer 2 between CLIENT_NET and FW_NET) between malware VM and pfSense. Runs TShark to capture all packets; invisible to malware.

---

**Detonation VM OS and Patch Information**

- **OS:** Microsoft Windows 10 Enterprise Evaluation
- **Build:** 22H2 (OS Build 19045.2006)
- **Architecture:** x64
- **Status:** Fully patched as of 2025-12-24 

---

**VirtualBox Networking** 

  -  **CLIENT_NET** (Internal Network): Windows VMs ↔ REMnux.
  -  **FW_NET** (Internal Network): REMnux ↔ pfSense LAN.
  -   pfSense LAN subnet: 192.168.1.0/24, DHCP enabled.
  -   pfSense WAN NIC: NAT towards host.

---

![Lab Topology Diagram](Images/labTopology.png) 
*VMs are hosted in Oracle VirtualBox*

---

## 4. Static Analysis

### 4.1 Sample Metadata (Summary)

| Attribute | Value |
|---|---|
| Malware Family | SnakeKeylogger |
| Sample Type | Multi-stage PowerShell loader -> .NET infostealer |
| Initial Loader | PowerShell script (`sample.ps1`, `stage2.ps1`) |
| Intermediate Loader | .NET assembly (`stage3.dll`, MAFIA loader) |
| Final Payload | VB.NET SnakeKeylogger (`endStage.exe`) |
| Execution Model | Predominantly fileless; PowerShell-based loader with in-memory .NET assemblies |
| Injection Technique | Process hollowing into `aspnet_compiler.exe` (LOLBin abuse) |
| In-Memory Loading | .NET assembly loaded via reflection (`Assembly.Load`) |
| Privilege Context | User context (`asInvoker`) |
| Persistence (Observed) | None established during detonation; runtime watchdog/respawn loop observed |
| Delivery Method | Unknown (commonly phishing-based in the wild) |

> Note: File names such as `sample.ps1`, `stage3.dll`, and `endStage.exe` are analyst-assigned labels used for clarity and do not reflect original filenames used by the threat actor.

### 4.2 Stage 1 PowerShell Loader

The analyzed sample was provided as a PowerShell script (`.ps1`) acting as the initial loader. The original delivery mechanism of this script could not be confirmed; however, its structure is consistent with common phishing-based delivery methods (e.g., LNK, HTML, ISO, or macro-based droppers invoking PowerShell).

The loader contains an embedded, obfuscated PowerShell payload that is decoded and executed entirely in memory. By default, no files are written to disk during this stage.

---

### 4.3 Stage 1 Obfuscation & Decryption Logic

The Stage 1 loader applies multiple lightweight obfuscation layers to conceal the next stage:

- Base64 encoding of the encrypted payload
- Base64 encoding of the encryption key
- RC4 stream cipher for payload decryption
- UTF-8 decoding to convert decrypted bytes into executable script content

The RC4 implementation follows a standard design, including a 256-byte S-box, key-scheduling algorithm (KSA), pseudo-random generation algorithm (PRGA), and XOR-based decryption. No advanced cryptography, key derivation, or per-victim keys were observed.

For analysis purposes, the execution flow was modified to output the decrypted plaintext instead of executing it directly, allowing full recovery of the embedded PowerShell code.

The PowerShell logic also revealed a long-running execution loop responsible for monitoring and respawning the LOLBin host process, indicating watchdog-style process management. The Stage 2 code is executed directly in memory using `Invoke-Expression (IEX)`, enabling fileless execution without writing the decrypted script to disk.

---

### 4.4 Stage 2 PowerShell In-Memory Loader

The decrypted Stage 2 PowerShell code acts as an in-memory loader responsible for delivering subsequent .NET components. This stage embeds two separate PE payloads:

- **Payload A:** A Base64-encoded .NET assembly (C#), decoded and loaded directly into memory using `System.Reflection.Assembly.Load()`.
- **Payload B:** A decimal-encoded byte array representing a PE file, beginning with the `MZ` header, indicating a valid Windows executable.

Neither payload is written to disk by default. Instead, both are handled in memory (Assembly.Load for Payload A; injected/mapped for Payload B).

---

### 4.5 .NET Loader (MAFIA) and Process Hollowing

The Base64-encoded .NET assembly (Payload A), referred to here as the *MAFIA* loader, is invoked from PowerShell via reflection. The method `MAFIA.DOWN::SHOOT(string path, byte[] payload)` is called externally, which explains the absence of internal call references within the assembly.

This loader implements a classic **RunPE / process hollowing** technique. It spawns the legitimate Microsoft-signed binary:
`C:\Windows\Microsoft.NET\Framework\v4.0.30319\aspnet_compiler.exe`

The process is created using the flags `CREATE_NO_WINDOW | CREATE_SUSPENDED` (`0x08000004`). The loader then injects and maps the embedded payload (Payload B) into the suspended `aspnet_compiler.exe` process and redirects execution to the payload’s entry point before resuming the process.

Memory analysis indicates that the resulting process retains mappings consistent with the legitimate `aspnet_compiler.exe` image while also containing the injected end-stage payload. This suggests a hollowing-style technique where execution is redirected to a manually mapped payload, likely without necessarily fully removing all original image mappings.

---

### 4.6 Final Payload Capabilities (SnakeKeylogger)

The injected payload (Payload B) is a VB.NET-based infostealer consistent with the SnakeKeylogger family. Static analysis revealed the following capabilities:

- Keystroke logging
- Clipboard data harvesting via WinAPI calls
- System profiling (hostname, OS details, geolocation, external IP)
- Collection and aggregation of stolen data into structured reports
- Anti-analysis behavior, including termination of selected security and monitoring processes

Obfuscation in this sample is lightweight and primarily limited to payload staging and configuration concealment, including layered encoding/encryption (Base64 + RC4) in the PowerShell stages and encrypted configuration strings in the final payload (Base64 + DES with an MD5-derived key).

#### Anti-Analysis / Anti-Bot Checks (Hardcoded IP Comparisons)

The end-stage payload contains logic controlled by an `EnabledAntiBot` flag that classifies the runtime environment as either `BotDetected` or `$BotClean`. As part of this check, the malware compares runtime-derived network identifiers (e.g., environment/network strings or IP-related values) against a small list of hardcoded IP addresses and marks the host as "bot-detected" when matches occur.

The IP values appear to serve as anti-analysis heuristics (e.g., identifying sandbox/cloud environments) and were not observed as command-and-control or exfiltration destinations during detonation.

Hardcoded values observed in code:

- `89.208.29.130`
- `69.55.5.249`
- `141.226.236.91`
- `3.23.155.57`

 > This classification logic influences downstream execution paths and may contribute to the observed differences in runtime stability and behavior across online and offline environments. 

---

### 4.7 Configuration & Exfiltration Channels

Static analysis identified support for multiple exfiltration mechanisms within the codebase, including SMTP, HTTP, FTP, and Telegram. However, only the SMTP channel was configured in this variant.

Encrypted configuration values embedded within the payload were decrypted offline using a custom Python script. The recovered configuration confirmed:

- SMTP-based exfiltration as the sole active channel
- Hardcoded credentials used to authenticate to the SMTP server
- A Gmail address configured as the exfiltration recipient

Other exfiltration mechanisms (FTP and Telegram) were present in code but contained empty or placeholder values, indicating they were disabled in this build.

To avoid enabling misuse, the decryption script and full credentials are not published; extracted indicators are documented in redacted form in the IOCs section.

---

### 4.8 Static Indicators of Interest

Static analysis revealed several detection-relevant characteristics:

- Multi-stage PowerShell-based loader
- RC4-decrypted in-memory payload execution
- Reflective loading of .NET assemblies
- Process hollowing into `aspnet_compiler.exe`
- Embedded but unused exfiltration modules
- Hardcoded SMTP configuration for data exfiltration

These indicators informed subsequent dynamic analysis and detection considerations.

---

## 5. Dynamic Analysis

Dynamic analysis was conducted to validate behaviors identified during static analysis and to observe runtime execution and network activity. Approximately five minutes of telemetry were collected using Process Monitor and Wireshark.

### 5.1 High-Level Execution Chain (Observed)

```text
Stage 1: Initial PowerShell Loader (`sample.ps1`)
        ↓ (Base64 / RC4 decode)
Stage 2: Decrypted PowerShell (`stage2.ps1`, executed via IEX)
        ↓
Stage 3: MAFIA .NET loader (`stage3.dll`, loaded in-memory via Assembly.Load)
        ↓
Stage 4: Spawns and hollows `aspnet_compiler.exe` (LOLBin abuse)
        ↓
Stage 5: SnakeKeylogger end-stage payload (`endStage.exe`, VB.NET, injected in-memory)
```
> Note: Reflective loading applies to the in-memory .NET assembly (stage3.dll / MAFIA loader), not to PowerShell script execution itself.

### 5.2 Process Execution & Runtime Behavior

During execution, the malware repeatedly spawned the legitimate Windows binary `aspnet_compiler.exe`, consistent with its use as a disposable host process for the injected payload. Additional short-lived processes such as `cmd.exe` and `choice.exe` were observed.

The following command was repeatedly executed:
`cmd.exe /C choice /C Y /N /D Y /T 3 & del "<path>\aspnet_compiler.exe"`
This behavior introduces a short execution delay followed by cleanup of the host process binary, after which a new instance is spawned. This pattern is consistent with lifecycle management of a hollowed LOLBin rather than reinitialization of malware logic.

#### Watchdog / Respawn Loop

Dynamic analysis indicates the presence of a PowerShell-based watchdog loop responsible for monitoring the execution of the hollowed `aspnet_compiler.exe` host process. If the process terminates or deletes itself, the script reinitializes the execution chain, recreating and injecting a new instance of `aspnet_compiler.exe` after a short delay.

This behavior explains the repeated spawning and cleanup of the host process observed during runtime and provides resilience against simple process termination. The watchdog logic operates entirely in user context and does not rely on registry-based persistence.

#### Runtime Variations & Error Handling

Runtime behavior differed based on network availability. When internet access was present, the malware consistently followed its intended watchdog-driven execution and cleanup cycle involving `cmd.exe` and `choice.exe`.

In offline execution scenarios, the hollowed `aspnet_compiler.exe` process frequently became unstable and crashed, resulting in the invocation of Windows Error Reporting (`WerFault.exe`).

Static analysis identified external IP and geo-IP lookup routines within the injected payload. When these network requests failed and returned null values, downstream logic appeared insufficiently guarded, which likely contributed to instability and process termination under offline conditions.

---

### 5.3 Privilege Context

The application manifest specifies `requestedExecutionLevel = asInvoker`. The malware executes successfully under a standard user context and does not require administrative privileges. No privilege escalation attempts were observed.

---

### 5.4 Network Activity

Multiple outbound HTTP and HTTPS connections were observed from `aspnet_compiler.exe` during runtime. The resolved IP addresses included:

- 158.101.44.242 (HTTP)
- 132.226.8.169 (HTTP)
- 132.226.247.73 (HTTP)
- 193.122.6.168 (HTTP)
- 188.114.96.3 (HTTPS)
- 188.114.97.3 (HTTPS)

These addresses resolved to common cloud and CDN infrastructure, primarily associated with Oracle Cloud and Cloudflare. None of these destinations were referenced in the malware code and are assessed as environmental noise resulting from execution within a legitimate .NET host process.

No attacker-controlled command-and-control endpoints or active exfiltration traffic were observed during the detonation window. This aligns with static findings indicating that SMTP was the only configured exfiltration mechanism, which did not activate during runtime.

---

### 5.5 Keylogging Activity

Keylogging and credential theft functionality executes within the injected .NET payload hosted inside `aspnet_compiler.exe`. Due to the fileless execution model and short-lived host processes, no additional observable artifacts were generated at the operating system level beyond those already identified statically.

---

### 5.6 Summary

Dynamic analysis corroborated the execution chain and techniques identified during static analysis, including LOLBin abuse, user-context execution, and lack of privilege escalation. No additional malicious behaviors or network indicators were discovered beyond those recovered statically.

---

## 6. Persistence Mechanisms

Static analysis of the final SnakeKeylogger payload revealed code paths associated with registry-based persistence, specifically the use of Run key entries. However, no persistence mechanisms were observed to be successfully established during dynamic analysis.

In the analyzed execution context, the malware operates in a predominantly fileless manner. The initial PowerShell loader executes entirely in memory, and the final payload is injected into a legitimate host process (`aspnet_compiler.exe`) without dropping a stable, disk-backed executable. As a result, the creation of a functional Run key entry would require a persistent file path or command reference, which was not observed during this analysis.

It is assessed that the Run key persistence logic is intended to be used in conjunction with an initial access mechanism that delivers a stable on-disk launcher (e.g., a dropped executable, script, or shortcut). Since only the PowerShell stage was available for analysis and no installer-style component was observed, this persistence mechanism was not triggered.

Overall, persistence in this sample appears to rely primarily on a PowerShell-based watchdog loop that continuously respawns the hollowed host process during active execution, rather than on long-term registry-based persistence across system reboots.

---

## 7. Memory / Forensic Artifacts

### 7.1 Injected Payload Recovery

Memory analysis successfully recovered the injected end-stage SnakeKeylogger payload from the hollowed `aspnet_compiler.exe` process. The extracted in-memory PE matches the original end-stage payload in file size, structure, timestamps, entry point, and embedded strings.

Minor discrepancies observed during static classification are attributable to manual mapping and partial PE header corruption introduced during the injection process, rather than the presence of a distinct or modified payload variant.

---

## 8. Indicators of Compromise (IOCs)

The following indicators were identified through static and dynamic analysis. Where applicable, indicators are provided in redacted or generalized form to avoid enabling misuse.

### 8.1 File Hashes

| Artifact | Type | Hash |
|-------|------|------|
| stage1_loader.ps1 | SHA256 | 342859bbd2e4e5aa82befc8dd426475c0d5ec38bef579075cb2da9fb11e1b72d	|
| stage2_decrypted.ps1 (recovered plaintext) | SHA256 | c9fa8672ebc98819b68abb64f29a3d2fcd5fcbc39fdc06a5d58ab6960cc5cc6e |
| MAFIA.dll (Payload A, in-memory .NET assembly, C#)| SHA256 | 06de5a0357ee482ae72fb31db12d077bcb3dacd75462d4c32a7024ae40c97c6a |
| lfwhUWZlmFnGhDYPudAJ.exe (Payload B, VB.NET stealer PE)| SHA256 | f068875a17ac20ca2b4c9acdd1db61d50d50d0e6d419ea7c154aa3882aa2758c |

Stage 2 and both payload binaries were recovered by decrypting/extracting embedded content from Stage 1 and were not provided as standalone files.

---

### 8.2 Processes

| Process Name | Description |
|------------|------------|
| powershell.exe | Initial loader execution |
| aspnet_compiler.exe | Hollowed LOLBin host process |
| cmd.exe | Delay and cleanup execution |
| choice.exe | Sleep/delay utility used in watchdog loop |

---

### 8.3 Registry

| Key | Value | Purpose |
|----|------|--------|
| HKCU\Software\Microsoft\Windows\CurrentVersion\Run | <not observed> | Run key persistence logic present in code but not triggered |

---

### 8.4 Network Indicators

#### Configured Exfiltration (Static)

- Domain: `alhadiyanplastic[.]com`
- SMTP host: `mail.alhadiyanplastic[.]com`
- SMTP server IP: `192.185.86.252`
- SMTP port: `587`
- Sender account: `r***i@alhadiyanplastic[.]com`
- Recipient: `n***o@gmail[.]com`
- Password: **[redacted]**

> Note: Credentials are intentionally omitted to avoid enabling misuse.

#### External IP / Geolocation Discovery (Static)

- `checkip.dyndns[.]org`
- `reallyfreegeoip[.]org`

---

### 8.5 Behavioral Indicators

- PowerShell-based RC4 decryption and in-memory execution (`Invoke-Expression`)
- Reflective loading of .NET assemblies
- Process hollowing into `aspnet_compiler.exe`
- PowerShell watchdog loop respawning a disposable host process
- Fileless execution with minimal disk artifacts

#### Watchdog Cleanup Loop (Host Process Deletion)

- `cmd.exe /C choice /C Y /N /D Y /T 3 & del "<path>\aspnet_compiler.exe"`

> This pattern implements a short delay and deletes the hollowed host binary, consistent with a respawn/watchdog lifecycle rather than normal `aspnet_compiler.exe` usage.

---

### 8.6 Notable Strings
- snake keylogger
- keylogger
- payload

---

## 9. Detections (Summary)

This sample can be detected through a combination of script analysis, process behavior monitoring, and network inspection rather than signature-based indicators alone.

Key detection opportunities include PowerShell execution of obfuscated Base64-encoded content, in-memory RC4 decryption routines, reflective loading of .NET assemblies, and the abuse of legitimate Windows binaries for execution. The continuous respawning of `aspnet_compiler.exe` via a PowerShell watchdog loop represents a particularly noisy and detectable behavioral pattern.

Network-based detections should focus on outbound SMTP traffic initiated from non-mail processes and connections to hardcoded infrastructure recovered via static analysis.

---

## 10. MITRE ATT&CK Mapping

| Tactic | Technique | ID | Description |
|------|---------|----|------------|
| Execution | Command and Scripting Interpreter: PowerShell | T1059.001 | PowerShell used as primary loader and execution mechanism |
| Execution | Native API | T1106 | Abuse of native execution mechanisms via managed .NET runtime |
| Defense Evasion | Obfuscated Files or Information | T1027 | Base64 encoding and RC4 encryption used to conceal payloads |
| Defense Evasion | Living Off the Land Binaries | T1218 | Abuse of `aspnet_compiler.exe` as a trusted execution host |
| Defense Evasion | Process Injection | T1055 | Process hollowing/RunPE into `aspnet_compiler.exe` to execute the payload under a trusted host process |
| Defense Evasion | Fileless Malware | T1027.004 | Payloads executed entirely in memory |
| Persistence | Boot or Logon Autostart Execution (Attempted) | T1547.001 | Registry Run key logic present but not triggered |
| Credential Access | Input Capture: Keylogging | T1056.001 | Keystroke and credential harvesting within injected payload |
| Collection | Clipboard Data | T1115 | Clipboard monitoring functionality present |
| Exfiltration | Exfiltration Over SMTP | T1048.003 | Stolen data transmitted via authenticated SMTP |
| Discovery | External IP Discovery | T1016 | Use of public IP discovery services |

---

## 11. Conclusion

This analysis examined a SnakeKeylogger sample delivered via a PowerShell-based loader employing lightweight obfuscation and fileless execution techniques. The malware relies on Base64 encoding and RC4 encryption to conceal embedded payloads and uses reflective .NET loading to execute malicious logic entirely in memory.

Execution is achieved through abuse of the legitimate Windows binary `aspnet_compiler.exe`, providing a trusted host process for the injected payload. A PowerShell-based watchdog loop ensures resiliency during runtime by continuously monitoring and respawning the host process, compensating for the lack of durable persistence.

Static analysis revealed support for multiple exfiltration channels, although only SMTP was configured in the analyzed variant. Dynamic analysis primarily served to confirm execution flow and did not uncover additional malicious behavior beyond that identified statically.

Overall, the sample represents commodity infostealer malware with minimal sophistication, relying on living-off-the-land techniques and operational simplicity rather than advanced evasion or exploitation mechanisms.

---

## 12. Limitations & Future Work

The analysis was limited by the absence of the original delivery mechanism and any installer-style components that may enable long-term persistence. As a result, certain code paths related to registry-based persistence could not be fully exercised or validated dynamically.

Future work may include:
- Extended runtime monitoring to observe delayed or conditional behaviors
- Development of behavioral detection rules targeting watchdog-style respawn loops
- Correlation with additional SnakeKeylogger variants to assess reuse and configuration overlap

---

## 13. Appendices

### Appendix A - Execution Timeline

- T+0: `sample.ps1` executed.
- T+?: Stage 2 PowerShell decrypted and executed via `IEX`.
- T+?: In-memory load of .NET loader (`stage3.dll` / MAFIA).
- T+?: Spawn + hollow `aspnet_compiler.exe`; inject end-stage payload.
- T+?: Watchdog loop repeats cleanup + respawn (via `cmd.exe` + `choice.exe` + `del`).
- Offline-only (observed): `aspnet_compiler.exe` instability -> `WerFault.exe`.

---
