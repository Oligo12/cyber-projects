# SnakeKeylogger Malware Analysis Report
**Author:** Nikola Marković  
**Date:** 2025-12-26                                                                                        
**Version:** v1.1

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)  
2. [Scope & Methodology](#2-scope--methodology)  
3. [Analysis Environment](#3-analysis-environment)  
4. [Static Analysis](#4-static-analysis)
    - [Sample Metadata (Summary)](#41-sample-metadata-summary)
    - [Stage 1 PowerShell Loader](#42-stage-1-powershell-loader)
    - [Stage 1 Obfuscation & Decryption Logic](#43-stage-1-obfuscation--decryption-logic)
    - [Stage 2 PowerShell In-Memory Loader](#44-stage-2-powershell-in-memory-loader)
    - [.NET Loader (MAFIA) and Process Hollowing](#45-net-loader-mafia-and-process-hollowing)
    - [Final Payload Capabilities (SnakeKeylogger)](#46-final-payload-capabilities-snakekeylogger)
    - [Configuration & Exfiltration Channels](#47-configuration--exfiltration-channels)
    - [Static Indicators of Interest](#48-static-indicators-of-interest)
5. [Dynamic Analysis](#5-dynamic-analysis)
   - [High-Level Execution Chain (Observed)](#51-high-level-execution-chain-observed)
   - [Process Execution & Runtime Behavior](#52-process-execution--runtime-behavior)
   - [Privilege Context](#53-privilege-context)
   - [Network Activity](#54-network-activity)
   - [Keylogging Activity](#55-keylogging-activity)
   - [Summary](#56-summary)
6. [Persistence Mechanisms](#6-persistence-mechanisms)
7. [Memory / Forensic Artifacts](#7-memory--forensic-artifacts)
   - [Injected Payload Recovery](#71-injected-payload-recovery) 
8. [Indicators of Compromise (IOCs)](#8-indicators-of-compromise-iocs)  
   - [File Hashes](#81-file-hashes)
   - [Processes](#82-processes)
   - [Registry](#83-registry)
   - [Network Indicators](#84-network-indicators)
   - [Behavioral Indicators](#85-behavioral-indicators)
   - [Notable Strings](#86-notable-strings)
9. [Detections (Summary)](#9-detections-summary)  
10. [MITRE ATT&CK Mapping](#10-mitre-attck-mapping)
11. [Conclusion](#11-conclusion)
12. [Limitations & Future Work](#12-limitations--future-work)
13. [Appendices](#13-appendices)
    - [Appendix A - Execution Timeline](#appendix-a---execution-timeline)
    - [Appendix B - KQL Rules](#appendix-b---kql-rules)

---

## 1. Executive Summary

This report documents the analysis of a Keylogger sample delivered via a multi-stage, PowerShell-based loader. The initial script employed Base64 encoding and RC4 encryption to conceal an embedded second-stage payload, which was decrypted at runtime and executed in memory via `Invoke-Expression`. The decrypted script subsequently loaded an intermediate .NET assembly in memory, which spawned and hollowed the legitimate Windows binary `aspnet_compiler.exe`, using it as a disposable host process for the final payload.

Static analysis confirmed functionality consistent with the Keylogger malware family, including credential harvesting and support for multiple data exfiltration mechanisms such as SMTP, HTTP, FTP, and Telegram. In the analyzed variant, only the SMTP module contained valid configuration data and embedded credentials; the remaining exfiltration methods were present in code but unconfigured.

Dynamic analysis using Process Monitor and Wireshark was performed primarily to validate the execution chain identified during static analysis. Runtime behavior confirmed the PowerShell staging logic, in-memory loading of the .NET loader, and abuse of `aspnet_compiler.exe` as a living-off-the-land host process. No active exfiltration traffic was observed during the detonation window, despite the presence of exfiltration logic in the payload.

Several outbound HTTP and HTTPS connections were observed from the hollowed `aspnet_compiler.exe` process. These resolved to common cloud and CDN infrastructure and are assessed as environmental noise associated with execution within a legitimate .NET host process, rather than attacker-controlled command-and-control activity.

Overall, the sample represents a commodity infostealer employing minimal obfuscation, with execution driven by in-memory PowerShell and .NET loaders and living-off-the-land binaries used primarily for payload hosting, lifecycle management, and defense evasion. Dynamic analysis corroborated static findings and did not reveal additional malicious capabilities beyond those identified through code analysis.

---

## 2. Scope & Methodology

### Scope

- Document the execution flow of a SnakeKeylogger sample staged via PowerShell.
- Identify the obfuscation layers used to conceal embedded payloads and recover plaintext code.
- Analyze decrypted payload logic to identify data collection functionality and supported exfiltration channels (and which are configured in this variant).
- Validate key behaviors with ProcMon/Wireshark and map techniques to MITRE ATT&CK.
- **Out of scope:** attribution, kernel/driver analysis, malware repacking.

### Methodology

- Revert to a clean snapshot between runs.
- Execute in an isolated Windows lab with controlled network access.
- Workflow:
  - Inspect PowerShell loader and extract/decrypt embedded payloads (Base64 -> RC4 -> UTF-8).
  - Review decrypted scripts/.NET components in dnSpy to identify functionality and configuration.
  - Confirm execution chain and observe runtime/network behavior using ProcMon, TCPView, and Wireshark.
- Collect logs/artifacts after each run for correlation.

### Tools Used

- **Static:** dnSpy, Detect It Easy (DIE), PowerShell ISE, CyberChef
- **Dynamic:** ProcMon, Wireshark, TCPView
- **Scripting:** Python (decryption), PowerShell (execution-flow modification and plaintext extraction)

---

## 3. Analysis Environment

**Lab Setup**

- **Microsoft Windows 10 Enterprise Evaluation (Version 22H2, OS Build 19045, FlareVM)** - malware detonation VM, patched, Windows Defender Antivirus and Windows Firewall disabled.
- **pfSense Firewall VM** - mediates all outbound traffic, configurable rules (DNS/HTTP/S only, ICMP, LAN-to-LAN, or full block). WAN interface connected through NAT.
- **REMnux VM** - positioned as a transparent bridge (Layer 2 between CLIENT_NET and FW_NET) between malware VM and pfSense. Runs TShark to capture all packets; invisible to malware.

---

**Detonation VM OS and Patch Information**

- **OS:** Microsoft Windows 10 Enterprise Evaluation
- **Build:** 22H2 (OS Build 19045.2006)
- **Architecture:** x64
- **Status:** Fully patched as of 2025-12-24 

---

**VirtualBox Networking** 

  -  **CLIENT_NET** (Internal Network): Windows VMs ↔ REMnux.
  -  **FW_NET** (Internal Network): REMnux ↔ pfSense LAN.
  -   pfSense LAN subnet: 192.168.1.0/24, DHCP enabled.
  -   pfSense WAN NIC: NAT towards host.

---

![Lab Topology Diagram](Images/labTopology.png) 
*VMs are hosted in Oracle VirtualBox*

---

## 4. Static Analysis

### 4.1 Sample Metadata (Summary)

| Attribute | Value |
|---|---|
| Malware Family | SnakeKeylogger |
| Sample Type | Multi-stage PowerShell loader -> .NET infostealer |
| Initial Loader | PowerShell script (`sample.ps1`, `stage2.ps1`) |
| Intermediate Loader | .NET assembly (`stage3.dll`, MAFIA loader) |
| Final Payload | VB.NET SnakeKeylogger (`endStage.exe`) |
| Execution Model | Predominantly fileless; PowerShell-based loader with in-memory .NET assemblies |
| Injection Technique | Process hollowing into `aspnet_compiler.exe` (LOLBin abuse) |
| In-Memory Loading | .NET assembly loaded via reflection (`Assembly.Load`) |
| Privilege Context | User context (`asInvoker`) |
| Persistence (Observed) | None established during detonation; runtime watchdog/respawn loop observed |
| Delivery Method | Unknown (commonly phishing-based in the wild) |

> Note: File names such as `sample.ps1`, `stage3.dll`, and `endStage.exe` are analyst-assigned labels used for clarity and do not reflect original filenames used by the threat actor.

### 4.2 Stage 1 PowerShell Loader

The analyzed sample was provided as a PowerShell script (`.ps1`) acting as the initial execution stage. The original delivery mechanism of this script could not be confirmed from the available artifacts.

This stage implements a typical PowerShell loader pattern: an embedded, obfuscated payload is decoded at runtime and executed directly in memory using PowerShell’s native execution capabilities. The script relies on in-memory decode-and-execute logic rather than dropping a secondary payload to disk, reducing filesystem artifacts and helping evade basic static detection.

While the exact delivery vector remains unknown, PowerShell-based in-memory loaders are commonly observed as part of phishing-driven infection chains, where an external dropper (e.g., shortcut files, HTML smuggling, ISO-mounted content, or macro-enabled documents) ultimately invokes `powershell.exe` to execute an encoded or obfuscated script. No files are written to disk during this stage by default.

---

### 4.3 Stage 1 Obfuscation & Decryption Logic

The Stage 1 loader applies multiple lightweight obfuscation layers to conceal the next stage:

- Base64 encoding of the encrypted payload
- Base64 encoding of the encryption key
- RC4 stream cipher for payload decryption
- UTF-8 decoding to convert decrypted bytes into executable script content

The RC4 implementation follows a standard design, including a 256-byte S-box, key-scheduling algorithm (KSA), pseudo-random generation algorithm (PRGA), and XOR-based decryption. No advanced cryptography, key derivation, or per-victim keys were observed.

For analysis purposes, the execution flow was modified to output the decrypted plaintext instead of executing it directly, allowing full recovery of the embedded PowerShell code.

The PowerShell logic also revealed a long-running execution loop responsible for monitoring and respawning the LOLBin host process, indicating watchdog-style process management. The Stage 2 code is executed directly in memory using `Invoke-Expression (IEX)`, enabling fileless execution without writing the decrypted script to disk.

---

### 4.4 Stage 2 PowerShell In-Memory Loader

The decrypted Stage 2 PowerShell code acts as an in-memory loader responsible for delivering subsequent .NET components. This stage embeds two separate PE payloads:

- **Payload A:** A Base64-encoded .NET assembly (C#), decoded and loaded directly into memory using `System.Reflection.Assembly.Load()`.
- **Payload B:** A decimal-encoded byte array representing a PE file, beginning with the `MZ` header, indicating a valid Windows executable.

Neither payload is written to disk by default. Instead, both are handled in memory (Assembly.Load for Payload A; injected/mapped for Payload B).

---

### 4.5 .NET Loader (MAFIA) and Process Hollowing

The Base64-encoded .NET assembly (Payload A), referred to here as the *MAFIA* loader, is invoked from PowerShell via reflection. The method `MAFIA.DOWN::SHOOT(string path, byte[] payload)` is called externally, which explains the absence of internal call references within the assembly.

This loader implements a classic **RunPE / process hollowing** technique. It spawns the legitimate Microsoft-signed binary:
`C:\Windows\Microsoft.NET\Framework\v4.0.30319\aspnet_compiler.exe`

The process is created using the flags `CREATE_NO_WINDOW | CREATE_SUSPENDED` (`0x08000004`). The loader then injects and maps the embedded payload (Payload B) into the suspended `aspnet_compiler.exe` process and redirects execution to the payload’s entry point before resuming the process.

Memory analysis indicates that the resulting process retains mappings consistent with the legitimate `aspnet_compiler.exe` image while also containing the injected end-stage payload. This suggests a hollowing-style technique where execution is redirected to a manually mapped payload, likely without necessarily fully removing all original image mappings.

---

### 4.6 Final Payload Capabilities (SnakeKeylogger)

The injected payload (Payload B) is a VB.NET-based infostealer consistent with the SnakeKeylogger family. Static analysis revealed the following capabilities:

- Keystroke logging
- Clipboard data harvesting via WinAPI calls
- System profiling (hostname, OS details, geolocation, external IP)
- Collection and aggregation of stolen data into structured reports
- Anti-analysis behavior, including termination of selected security and monitoring processes

Obfuscation in this sample is lightweight and primarily limited to payload staging and configuration concealment, including layered encoding/encryption (Base64 + RC4) in the PowerShell stages and encrypted configuration strings in the final payload (Base64 + DES with an MD5-derived key).

#### Anti-Analysis / Anti-Bot Checks (Hardcoded IP Comparisons)

The end-stage payload contains logic controlled by an `EnabledAntiBot` flag that classifies the runtime environment as either `BotDetected` or `$BotClean`. As part of this check, the malware compares runtime-derived network identifiers (e.g., environment/network strings or IP-related values) against a small list of hardcoded IP addresses and marks the host as "bot-detected" when matches occur.

The IP values appear to serve as anti-analysis heuristics (e.g., identifying sandbox/cloud environments) and were not observed as command-and-control or exfiltration destinations during detonation.

Hardcoded values observed in code:

- `89.208.29.130`
- `69.55.5.249`
- `141.226.236.91`
- `3.23.155.57`

 > This classification logic influences downstream execution paths and may contribute to the observed differences in runtime stability and behavior across online and offline environments.

#### Defensive Process Termination & Self-Protection Logic

The final payload implements aggressive self-defense behavior designed to disrupt security tools and evade analysis. During execution, the malware enumerates all running processes and compares their names against a large hardcoded list associated with antivirus products, endpoint detection tools, debuggers, network analyzers, virtualization software, and incident response utilities. When a match is found, the corresponding process is forcibly terminated.

In addition to external process termination, the payload includes multiple self-termination checks. If specific processes are detected or if particular files exist on disk, the malware immediately terminates its own execution. These checks appear intended to prevent execution in sandboxed, instrumented, or previously infected environments.

This defensive logic likely contributed to the absence of observable persistence during dynamic analysis. Early self-termination or gated execution paths may prevent registry-based persistence routines from being reached, particularly in environments containing security tooling or lacking a stable on-disk payload.

---

### 4.7 Configuration & Exfiltration Channels

Static analysis identified support for multiple exfiltration mechanisms within the codebase, including SMTP, HTTP, FTP, and Telegram. However, only the SMTP channel was configured in this variant.

Encrypted configuration values embedded within the payload were decrypted offline using a custom Python script. The recovered configuration confirmed:

- SMTP-based exfiltration as the sole active channel
- Hardcoded credentials used to authenticate to the SMTP server
- A Gmail address configured as the exfiltration recipient

Other exfiltration mechanisms (FTP and Telegram) were present in code but contained empty or placeholder values, indicating they were disabled in this build.

To avoid enabling misuse, the decryption script and full credentials are not published; extracted indicators are documented in redacted form in the IOCs section.

---

### 4.8 Static Indicators of Interest

Static analysis revealed several detection-relevant characteristics:

- Multi-stage PowerShell-based loader
- RC4-decrypted in-memory payload execution
- Reflective loading of .NET assemblies
- Process hollowing into `aspnet_compiler.exe`
- Embedded but unused exfiltration modules
- Hardcoded SMTP configuration for data exfiltration

These indicators informed subsequent dynamic analysis and detection considerations.

---

## 5. Dynamic Analysis

Dynamic analysis was conducted to validate behaviors identified during static analysis and to observe runtime execution and network activity. Approximately five minutes of telemetry were collected using Process Monitor and Wireshark.

### 5.1 High-Level Execution Chain (Observed)

```text
Stage 1: Initial PowerShell Loader (`sample.ps1`)
        ↓ (Base64 / RC4 decode)
Stage 2: Decrypted PowerShell (`stage2.ps1`, executed via IEX)
        ↓
Stage 3: MAFIA .NET loader (`stage3.dll`, loaded in-memory via Assembly.Load)
        ↓
Stage 4: Spawns and hollows `aspnet_compiler.exe` (LOLBin abuse)
        ↓
Stage 5: SnakeKeylogger end-stage payload (`endStage.exe`, VB.NET, injected in-memory)
```
> Note: Reflective loading applies to the in-memory .NET assembly (stage3.dll / MAFIA loader), not to PowerShell script execution itself.

### 5.2 Process Execution & Runtime Behavior

During execution, the malware repeatedly spawned the legitimate Windows binary `aspnet_compiler.exe`, consistent with its use as a disposable host process for the injected payload. Additional short-lived processes such as `cmd.exe` and `choice.exe` were observed.

The following command was repeatedly executed:
`cmd.exe /C choice /C Y /N /D Y /T 3 & del "<path>\aspnet_compiler.exe"`
This behavior introduces a short execution delay followed by cleanup of the host process binary, after which a new instance is spawned. This pattern is consistent with lifecycle management of a hollowed LOLBin rather than reinitialization of malware logic.

#### Watchdog / Respawn Loop

Dynamic analysis indicates the presence of a PowerShell-based watchdog loop responsible for monitoring the execution of the hollowed `aspnet_compiler.exe` host process. If the process terminates or deletes itself, the script reinitializes the execution chain, recreating and injecting a new instance of `aspnet_compiler.exe` after a short delay.

This behavior explains the repeated spawning and cleanup of the host process observed during runtime and provides resilience against simple process termination. The watchdog logic operates entirely in user context and does not rely on registry-based persistence.

#### Runtime Variations & Error Handling

Runtime behavior differed based on network availability. When internet access was present, the malware consistently followed its intended watchdog-driven execution and cleanup cycle involving `cmd.exe` and `choice.exe`.

In offline execution scenarios, the hollowed `aspnet_compiler.exe` process frequently became unstable and crashed, resulting in the invocation of Windows Error Reporting (`WerFault.exe`).

Static analysis identified external IP and geo-IP lookup routines within the injected payload. When these network requests failed and returned null values, downstream logic appeared insufficiently guarded, which likely contributed to instability and process termination under offline conditions.

---

### 5.3 Privilege Context

The application manifest specifies `requestedExecutionLevel = asInvoker`. The malware executes successfully under a standard user context and does not require administrative privileges. No privilege escalation attempts were observed.

---

### 5.4 Network Activity

Multiple outbound HTTP and HTTPS connections were observed from `aspnet_compiler.exe` during runtime. The resolved IP addresses included:

- 158.101.44.242 (HTTP)
- 132.226.8.169 (HTTP)
- 132.226.247.73 (HTTP)
- 193.122.6.168 (HTTP)
- 188.114.96.3 (HTTPS)
- 188.114.97.3 (HTTPS)

These addresses resolved to common cloud and CDN infrastructure, primarily associated with Oracle Cloud and Cloudflare. None of these destinations were referenced in the malware code and are assessed as environmental noise resulting from execution within a legitimate .NET host process.

No attacker-controlled command-and-control endpoints or active exfiltration traffic were observed during the detonation window. This aligns with static findings indicating that SMTP was the only configured exfiltration mechanism, which did not activate during runtime.

---

### 5.5 Keylogging Activity

Keylogging and credential theft functionality executes within the injected .NET payload hosted inside `aspnet_compiler.exe`. Due to the fileless execution model and short-lived host processes, no additional observable artifacts were generated at the operating system level beyond those already identified statically.

---

### 5.6 Summary

Dynamic analysis corroborated the execution chain and techniques identified during static analysis, including LOLBin abuse, user-context execution, and lack of privilege escalation. No additional malicious behaviors or network indicators were discovered beyond those recovered statically.

---

## 6. Persistence Mechanisms

Static analysis of the final SnakeKeylogger payload revealed code paths associated with registry-based persistence, specifically the creation of Run key entries intended to launch the malware on user logon.

However, no persistence mechanisms were observed to be successfully established during dynamic analysis.

The analyzed execution chain was predominantly fileless: the initial PowerShell loader executed entirely in memory, and the final payload was injected into a legitimate host process (`aspnet_compiler.exe`) without a stable, disk-backed executable. As a result, the creation of a functional Run key entry would require a persistent on-disk file path, which was not present in the analyzed sample.

Additionally, the payload implements self-protection and anti-analysis logic, including aggressive termination of security and monitoring processes and multiple self-termination conditions based on environmental checks. These controls may prevent persistence routines from being reached in instrumented or sandboxed environments.

It is assessed that the registry-based persistence logic is intended for use in conjunction with an initial access mechanism that delivers a stable on-disk launcher (e.g., a dropped executable or installer component), which was not present in this analysis.

Although the payload contains a helper routine to write a Run key entry under `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`, static call analysis did not identify any direct references to this routine within the end-stage assembly (no observed call sites). As a result, persistence was not established during detonation.

---

## 7. Memory / Forensic Artifacts

### 7.1 Injected Payload Recovery

Memory analysis successfully recovered the injected end-stage SnakeKeylogger payload from the hollowed `aspnet_compiler.exe` process. The extracted in-memory PE matches the original end-stage payload in file size, structure, timestamps, entry point, and embedded strings.

Minor discrepancies observed during static classification are attributable to manual mapping and partial PE header corruption introduced during the injection process, rather than the presence of a distinct or modified payload variant.

---

## 8. Indicators of Compromise (IOCs)

The following indicators were identified through static and dynamic analysis. Where applicable, indicators are provided in redacted or generalized form to avoid enabling misuse.

### 8.1 File Hashes

| Artifact | Type | Hash |
|-------|------|------|
| stage1_loader.ps1 | SHA256 | 342859bbd2e4e5aa82befc8dd426475c0d5ec38bef579075cb2da9fb11e1b72d	|
| stage2_decrypted.ps1 (recovered plaintext) | SHA256 | c9fa8672ebc98819b68abb64f29a3d2fcd5fcbc39fdc06a5d58ab6960cc5cc6e |
| MAFIA.dll (Payload A, in-memory .NET assembly, C#)| SHA256 | 06de5a0357ee482ae72fb31db12d077bcb3dacd75462d4c32a7024ae40c97c6a |
| lfwhUWZlmFnGhDYPudAJ.exe (Payload B, VB.NET stealer PE)| SHA256 | f068875a17ac20ca2b4c9acdd1db61d50d50d0e6d419ea7c154aa3882aa2758c |

Stage 2 and both payload binaries were recovered by decrypting/extracting embedded content from Stage 1 and were not provided as standalone files.

---

### 8.2 Processes

| Process Name | Description |
|------------|------------|
| powershell.exe | Initial loader execution |
| aspnet_compiler.exe | Hollowed LOLBin host process |
| cmd.exe | Delay and cleanup execution |
| choice.exe | Sleep/delay utility used in watchdog loop |

---

### 8.3 Registry

| Key | Value | Purpose |
|----|------|--------|
| HKCU\Software\Microsoft\Windows\CurrentVersion\Run | <not observed> | Run key persistence logic present in code but not triggered |

---

### 8.4 Network Indicators

#### Configured Exfiltration (Static)

- Domain: `alhadiyanplastic[.]com`
- SMTP host: `mail.alhadiyanplastic[.]com`
- SMTP server IP: `192.185.86.252`
- SMTP port: `587`
- Sender account: `r***i@alhadiyanplastic[.]com`
- Recipient: `n***o@gmail[.]com`
- Password: **[redacted]**

> Note: Credentials are intentionally omitted to avoid enabling misuse.

#### External IP / Geolocation Discovery (Static)

- `checkip.dyndns[.]org`
- `reallyfreegeoip[.]org`

---

### 8.5 Behavioral Indicators

- PowerShell-based RC4 decryption and in-memory execution (`Invoke-Expression`)
- Reflective loading of .NET assemblies
- Process hollowing into `aspnet_compiler.exe`
- PowerShell watchdog loop respawning a disposable host process
- Fileless execution with minimal disk artifacts

#### Watchdog Cleanup Loop (Host Process Deletion)

- `cmd.exe /C choice /C Y /N /D Y /T 3 & del "<path>\aspnet_compiler.exe"`

> This pattern implements a short delay and deletes the hollowed host binary, consistent with a respawn/watchdog lifecycle rather than normal `aspnet_compiler.exe` usage.

---

### 8.6 Notable Strings
- snake keylogger
- keylogger
- payload

---

## 9. Detections (Summary)

This sample can be detected through a combination of script analysis, process behavior monitoring, and network inspection rather than signature-based indicators alone.

Key detection opportunities include PowerShell execution of obfuscated Base64-encoded content, in-memory RC4 decryption routines, reflective loading of .NET assemblies, and the abuse of legitimate Windows binaries for execution. The continuous respawning of `aspnet_compiler.exe` via a PowerShell watchdog loop represents a particularly noisy and detectable behavioral pattern.

Network-based detections should focus on outbound SMTP traffic initiated from non-mail processes and connections to hardcoded infrastructure recovered via static analysis.

---

## 10. MITRE ATT&CK Mapping

| Tactic | Technique | ID | Description |
|------|---------|----|------------|
| Execution | Command and Scripting Interpreter: PowerShell | T1059.001 | PowerShell used as primary loader and execution mechanism |
| Execution | Native API | T1106 | Abuse of native execution mechanisms via managed .NET runtime |
| Defense Evasion | Obfuscated Files or Information | T1027 | Base64 encoding and RC4 encryption used to conceal payloads |
| Defense Evasion | Living Off the Land Binaries | T1218 | Abuse of `aspnet_compiler.exe` as a trusted execution host |
| Defense Evasion | Process Injection | T1055 | Process hollowing/RunPE into `aspnet_compiler.exe` to execute the payload under a trusted host process |
| Defense Evasion | Fileless Malware | T1027.004 | Payloads executed entirely in memory |
| Persistence | Boot or Logon Autostart Execution (Attempted) | T1547.001 | Registry Run key logic present but not triggered |
| Credential Access | Input Capture: Keylogging | T1056.001 | Keystroke and credential harvesting within injected payload |
| Collection | Clipboard Data | T1115 | Clipboard monitoring functionality present |
| Exfiltration | Exfiltration Over SMTP | T1048.003 | Stolen data transmitted via authenticated SMTP |
| Discovery | External IP Discovery | T1016 | Use of public IP discovery services |

---

## 11. Conclusion

This analysis examined a SnakeKeylogger sample delivered via a PowerShell-based loader employing lightweight obfuscation and fileless execution techniques. The malware relies on Base64 encoding and RC4 encryption to conceal embedded payloads and uses reflective .NET loading to execute malicious logic entirely in memory.

Execution is achieved through abuse of the legitimate Windows binary `aspnet_compiler.exe`, providing a trusted host process for the injected payload. A PowerShell-based watchdog loop ensures resiliency during runtime by continuously monitoring and respawning the host process, compensating for the lack of durable persistence.

Static analysis revealed support for multiple exfiltration channels, although only SMTP was configured in the analyzed variant. Dynamic analysis primarily served to confirm execution flow and did not uncover additional malicious behavior beyond that identified statically.

Overall, the sample represents commodity infostealer malware with minimal sophistication, relying on living-off-the-land techniques and operational simplicity rather than advanced evasion or exploitation mechanisms.

---

## 12. Limitations & Future Work

The analysis was limited by the absence of the original delivery mechanism and any installer-style components that may enable long-term persistence. As a result, certain code paths related to registry-based persistence could not be fully exercised or validated dynamically.

Future work may include:
- Extended runtime monitoring to observe delayed or conditional behaviors
- Development of behavioral detection rules targeting watchdog-style respawn loops
- Correlation with additional SnakeKeylogger variants to assess reuse and configuration overlap

---

## 13. Appendices

### Appendix A - Execution Timeline

- T+0: `sample.ps1` executed.
- T+?: Stage 2 PowerShell decrypted and executed via `IEX`.
- T+?: In-memory load of .NET loader (`stage3.dll` / MAFIA).
- T+?: Spawn + hollow `aspnet_compiler.exe`; inject end-stage payload.
- T+?: Watchdog loop repeats cleanup + respawn (via `cmd.exe` + `choice.exe` + `del`).
- Offline-only (observed): `aspnet_compiler.exe` instability -> `WerFault.exe`.

---

### Appendix B - KQL Rules

#### PowerShell In-Memory Loader Behavior (ScriptBlock 4104)
```kusto
// Rule: PowerShell In-Memory Loader Behavior (ScriptBlock 4104)
// Why: SnakeKeylogger staging leveraged obfuscation, dynamic execution (IEX), and in-memory loading to avoid on-disk artifacts.
// Lab note: Score-based behavioral rule; strict thresholds used to preserve signal during analysis.
// Prod note: Expand allowlists for known admin tooling and tune minScore based on environment baseline.

let minScore = 2; // tuning: increase to 3+ in noisy environments
let minBase64Len = 200;

let benign_cmd_patterns = dynamic([
  // Lab allowlist for common admin / management tooling (expand per environment)
  "\\\\program files\\\\",                   // broad
  "chocolatey",
  "winget",
  "azureconnectedmachineagent",
  "azuremonitoragent",
  "microsoft intune",
  "sccm",
  "ansible",
  "saltstack"
]);

let is_benign = (txt:string) {
  tolower(tostring(txt)) matches regex strcat(@"(", strcat_array(benign_cmd_patterns, "|"), @")")
};

win_4104_powershell_scriptblock
| where isnotempty(script_block_text)
| extend sb = tolower(tostring(script_block_text))
| where not(is_benign(sb))
| extend
    // Loader-related behavior indicators (individually weak, strong in combination)
    ind_iex        = iif(sb has "invoke-expression" or sb has " iex " or sb startswith "iex ", 1, 0),
    ind_b64        = iif(sb has "frombase64string" or sb matches regex strcat(@"[a-z0-9\+/]{", tostring(minBase64Len), ",}={0,2}"), 1, 0),
    ind_reflect    = iif(sb has "assembly::load" or sb has "system.reflection.assembly" or sb has "reflection.assembly" or sb has "add-type", 1, 0),
    ind_web        = iif(sb has "invoke-webrequest" or sb has "downloadstring" or sb has "webclient" or sb has "httpclient", 1, 0),
    ind_xor_bytes  = iif(sb has "-bxor" or sb has "[byte[]]" or (sb has "utf8.getstring" and sb has "getbytes"), 1, 0)
| extend score = ind_iex + ind_b64 + ind_reflect + ind_web + ind_xor_bytes
| where score >= minScore
| extend det_rule = case(
    score >= 4, "PS_Loader_HighConfidence",
    score == 3, "PS_Loader_MediumHigh",
               "PS_Loader_Medium"
  )
| extend evidence = strcat(
    "score=", tostring(score),
    " | IEX=", tostring(ind_iex),
    " B64=", tostring(ind_b64),
    " Reflect=", tostring(ind_reflect),
    " Web=", tostring(ind_web),
    " XOR/Bytes=", tostring(ind_xor_bytes)
  )
| project time_generated, computer, det_rule,
          user_name = tostring(column_ifexists("user_name","")),
          evidence,
          script_block_text
| sort by time_generated desc
```

#### Delayed Command Execution + Respawn Watchdog Loop

````kusto
// Rule: Delayed Command Execution + Respawn Watchdog Loop
// Why: Malware commonly delays execution and uses respawn/watchdog loops to evade sandboxes and survive crashes or remediation.
// Lab note: Rule is intentionally strict (tight timing gaps, repeated executions) to reduce noise during analysis.
// Prod note: Tune timing thresholds and add contextual allowlists; correlate with persistence and LOLBin detections.

// triggers:
// - trigger_a: delay + action in same command line, repeated within a window (reduces noise)
// - trigger_b: respawn loop in a time window (only alert on loops containing delay+action)
// suppression: trigger_b overrides trigger_a per (window_start, computer, user, img_lc, cmd_norm)

let lookback = 2h;

// trigger_b tuning
let min_gap = 1s;
let max_gap = 30s;
let window = 5m;          // alerting chunk size
let min_starts = 4;       // 4+ starts inside each window

// primitives
let delay_terms = dynamic([
  "timeout", "timeout.exe",
  "ping -n", "ping.exe -n",
  "choice /t", "choice.exe /t", "choice /c", "choice.exe /c",
  "start-sleep"
]);

let action_terms = dynamic([
  "del", "erase",
  "move", "copy",
  "reg add", "reg.exe add",
  "schtasks", "schtasks.exe",
  "rundll32", "rundll32.exe",
  "mshta", "mshta.exe",
  "wscript", "wscript.exe",
  "cscript", "cscript.exe",
  "bitsadmin", "bitsadmin.exe",
  "certutil", "certutil.exe"
]);

let script_hosts = dynamic([
  "powershell.exe","pwsh.exe","powershell_ise.exe",
  "wscript.exe","cscript.exe","mshta.exe","cmd.exe"
]);

// ---- base tables (sysmon only)
let p1 =
    Sysmon_1_ProcessCreate()
    | where time_generated >= ago(lookback)
    | extend
        time_generated_utc      = time_generated,
        computer                = tostring(computer),
        user_name               = tostring(user_name),
        process_path            = tostring(process_path),
        process_name            = tolower(tostring(process_name)),
        command_line            = tostring(command_line),
        parent_process_path     = tostring(parent_process_path),
        parent_process_name     = tolower(tostring(parent_process_name)),
        // optional fields (won't break if missing)
        process_guid            = tostring(column_ifexists("process_guid","")),
        process_id              = tostring(column_ifexists("process_id","")),
        parent_process_guid     = tostring(column_ifexists("parent_process_guid","")),
        parent_process_id       = tostring(column_ifexists("parent_process_id","")),
        current_directory       = tostring(column_ifexists("current_directory","")),
        integrity_level         = tostring(column_ifexists("integrity_level","")),
        hashes                  = tostring(column_ifexists("hashes",""))
    | extend
        cmd_lc = tolower(command_line),
        img_lc = tolower(process_path),
        window_start_utc = bin(time_generated_utc, window)
    | project
        time_generated_utc, window_start_utc, computer, user_name,
        process_path, process_name, command_line,
        parent_process_path, parent_process_name,
        process_guid, process_id, parent_process_guid, parent_process_id,
        current_directory, integrity_level, hashes,
        cmd_lc, img_lc;

let p5 =
    Sysmon_5_ProcessTerminate()
    | where time_generated >= ago(lookback)
    | extend
        time_generated_utc = time_generated,
        computer           = tostring(computer),
        user_name          = tostring(user_name),
        process_path       = tostring(process_path),
        process_name       = tolower(tostring(process_name)),
        process_guid       = tostring(column_ifexists("process_guid","")),
        process_id         = tostring(column_ifexists("process_id",""))
    | extend img_lc = tolower(process_path)
    | project time_generated_utc, computer, user_name, process_path, process_name, img_lc, process_guid, process_id;

// terminate enrichment (used by trigger_b)
// Do not group terminations by cmdline; join must remain 1:1 per (host,user,image,window)
let term_counts =
    p5
    | extend window_start_utc = bin(time_generated_utc, window)
    | summarize
        terminate_count = count(),
        terminate_pids  = make_set(process_id, 32),
        terminate_guids = make_set(process_guid, 32)
      by computer, user_name, img_lc, window_start_utc;

// ------------------------------
// trigger_a: delay + action in same command line, repeated within window
let trigger_a =
    p1
    | where isnotempty(cmd_lc)
    | where cmd_lc has_any (delay_terms) and cmd_lc has_any (action_terms)
    | extend cmd_norm = replace_regex(cmd_lc, @"[""']+", "")
    | extend cmd_norm = replace_regex(cmd_norm, @"\s+", " ")
    | extend cmd_norm = trim(" ", cmd_norm)
    | summarize
        starts_in_window = count(),
        example_command_line = any(command_line),
        example_process_path = any(process_path),
        example_process_name = any(process_name),
        example_parent_path  = any(parent_process_path),
        example_parent_name  = any(parent_process_name),
        example_process_guid = any(process_guid),
        example_process_id   = any(process_id),
        example_parent_process_guid = any(parent_process_guid),
        example_parent_process_id   = any(parent_process_id),
        example_current_directory   = any(current_directory),
        example_integrity_level     = any(integrity_level),
        example_hashes              = any(hashes)
      by window_start_utc, computer, user_name, img_lc, cmd_norm
    | where starts_in_window >= 4
    | extend
        trigger_type = "trigger_a_delay_plus_action_windowed",
        reason = strcat(
            "delay+action within window: starts=", tostring(starts_in_window),
            "; window=", tostring(window),
            iff(tolower(example_parent_name) in (script_hosts), " | parent_is_script_host", "")
        )
    | project
        time_generated_utc = window_start_utc,
        window_start_utc,
        computer, user_name,
        img_lc,
        cmd_norm,
        trigger_type, reason,
        process_path = example_process_path,
        process_name = tostring(split(tolower(example_process_path), "\\")[-1]),
        command_line = example_command_line,
        parent_process_path = example_parent_path,
        parent_process_name = example_parent_name,
        process_guid = example_process_guid,
        process_id = example_process_id,
        parent_process_guid = example_parent_process_guid,
        parent_process_id = example_parent_process_id,
        current_directory = example_current_directory,
        integrity_level = example_integrity_level,
        hashes = example_hashes,
        starts_in_window;

// ------------------------------
// trigger_b: windowed respawn loop (only alert on loops that contain delay+action)
let trigger_b =
    p1
    | where isnotempty(img_lc) and isnotempty(cmd_lc)
    | where cmd_lc has_any (action_terms) and cmd_lc has_any (delay_terms)
    | extend cmd_norm = replace_regex(cmd_lc, @"[""']+", "")
    | extend cmd_norm = replace_regex(cmd_norm, @"\s+", " ")
    | extend cmd_norm = trim(" ", cmd_norm)
    | sort by computer asc, user_name asc, img_lc asc, cmd_lc asc, window_start_utc asc, time_generated_utc asc
    | serialize
    | extend prev_t = prev(time_generated_utc)
    | extend same_key =
        (prev(computer) == computer
         and prev(user_name) == user_name
         and prev(img_lc) == img_lc
         and prev(cmd_lc) == cmd_lc
         and prev(window_start_utc) == window_start_utc)
    // FIX: simpler + safer gap calc
    | extend gap = time_generated_utc - prev_t
    | where same_key and gap between (min_gap .. max_gap)
    | summarize
        links_in_window              = count(),
        first_seen_utc               = min(time_generated_utc),
        last_seen_utc                = max(time_generated_utc),
        min_gap_seen                 = min(gap),
        max_gap_seen                 = max(gap),
        example_command_line         = any(command_line),
        example_process_path         = any(process_path),
        example_parent_path          = any(parent_process_path),
        example_parent_name          = any(parent_process_name),
        example_process_guid         = any(process_guid),
        example_process_id           = any(process_id),
        example_parent_process_guid  = any(parent_process_guid),
        example_parent_process_id    = any(parent_process_id),
        example_current_directory    = any(current_directory),
        example_integrity_level      = any(integrity_level),
        example_hashes               = any(hashes)
      by window_start_utc, computer, user_name, img_lc, cmd_norm
    | extend starts_in_window = links_in_window + 1
    | where starts_in_window >= min_starts
    | join kind=leftouter term_counts on computer, user_name, img_lc, window_start_utc
    | extend
        trigger_type = "trigger_b_respawn_loop_windowed",
        reason = strcat(
            "respawn loop within window: starts=", tostring(starts_in_window),
            "; window=", tostring(window),
            "; gap_seen=", tostring(min_gap_seen), "-", tostring(max_gap_seen),
            iff(isnull(terminate_count), "", strcat(" | terminations=", tostring(terminate_count)))
        )
    | project
        time_generated_utc = window_start_utc,
        window_start_utc,
        computer, user_name,
        img_lc,
        cmd_norm,
        trigger_type, reason,
        process_path = example_process_path,
        process_name = tostring(split(tolower(example_process_path), "\\")[-1]),
        command_line = example_command_line,
        parent_process_path = example_parent_path,
        parent_process_name = example_parent_name,
        process_guid = example_process_guid,
        process_id = example_process_id,
        parent_process_guid = example_parent_process_guid,
        parent_process_id = example_parent_process_id,
        current_directory = example_current_directory,
        integrity_level = example_integrity_level,
        hashes = example_hashes,
        starts_in_window,
        min_gap_seen,
        max_gap_seen,
        terminate_count,
        terminate_pids,
        terminate_guids;

// final output
union trigger_a, trigger_b
| extend trigger_rank = case(trigger_type startswith "trigger_b", 2, 1)
// Suppression: keep highest-signal trigger per (window, host, user, image, cmd_norm)
| summarize arg_max(trigger_rank, *) by window_start_utc, computer, user_name, img_lc, cmd_norm
| project-away trigger_rank
| extend
    severity   = case(trigger_type startswith "trigger_b", "high", "medium"),
    confidence = case(trigger_type startswith "trigger_b", 85, 65)
| order by time_generated_utc desc
````
